/*
 * ===Begin Copyright Notice===
 *
 *  NOTICE
 *
 *  THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS CONFIDENTIAL INFORMATION OF
 *  LIFECOSYS AND/OR ITS AFFILIATES OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED
 *  WITHOUT PRIOR WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND ADAPT
 *  THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH THE TERMS OF THEIR
 *  SOFTWARE LICENSE AGREEMENT. ALL OTHER RIGHTS RESERVED.
 *
 *  (c) COPYRIGHT 2013 LIFECOCYS. ALL RIGHTS RESERVED. THE WORD AND DESIGN
 *  MARKS SET FORTH HEREIN ARE TRADEMARKS AND/OR REGISTERED TRADEMARKS OF
 *  LIFECOSYS AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS RESERVED.
 *  ALL LIFECOSYS TRADEMARKS LISTED HEREIN ARE THE PROPERTY OF THEIR RESPECTIVE
 *  OWNERS.
 *
 *  ===End Copyright Notice===
 */

package com.lifecosys.toolkit.proxy

import java.security.spec.{ RSAPrivateCrtKeySpec, RSAPublicKeySpec }
import java.security.{ SecureRandom, KeyPairGenerator, Security, KeyFactory }
import org.bouncycastle.jce.provider.BouncyCastleProvider
import java.net.{ URL, InetSocketAddress }
import java.util.regex.Pattern
import org.jboss.netty.channel.{ ChannelFuture, ChannelFutureListener, Channel }
import org.jboss.netty.buffer.{ ChannelBuffer, ChannelBuffers }
import org.bouncycastle.util.encoders.Hex
import java.nio.charset.Charset
import org.jasypt.encryption.pbe.StandardPBEByteEncryptor
import java.util.zip.{ Inflater, Deflater }
import javax.net.ssl.{ X509TrustManager, SSLContext }
import java.security.cert.X509Certificate
import org.jboss.netty.handler.codec.http.{ HttpChunk, HttpMessage }
import org.apache.commons.io.{ IOUtils, HexDump }
import java.io.{ ByteArrayInputStream, ByteArrayOutputStream }
import scala.Some

/**
 *
 *
 * @author Young Gu
 * @version 1.0 12/19/12 4:57 PM
 */
object Utils {
  val UTF8: Charset = Charset.forName("UTF-8")
  val httpPattern = Pattern.compile("^https?://.*", Pattern.CASE_INSENSITIVE)
  val hostPortPattern = """([^:]*)(:?)(\d{0,5})""".r
  val connectProxyResponse: String = "HTTP/1.1 200 Connection established\r\n\r\n"
  val deflater = new Deflater
  val inflater = new Inflater

  var channelFutures = scala.collection.mutable.MutableList[ChannelFuture]()

  lazy val cryptor = {
    val standardEncryptor = new StandardPBEByteEncryptor
    standardEncryptor.setProviderName("BC")
    standardEncryptor.setAlgorithm("PBEWithSHAAnd3KeyTripleDES")
    standardEncryptor.setPassword("""nFJ@54GiretJGEg32%##43bdfw v345&78(&!~_r5w5 b^%%^875345@$$#@@$24!@#(@$$@%$@ VCDN{}Po}}PV D[GEJ G_""")
    standardEncryptor
  }

  def extractHostAndPort(uri: String) = {

    val trimmedUri = uri.trim
    val url = if (trimmedUri.startsWith("http"))
      new URL(trimmedUri)
    else
      new URL("http://" + trimmedUri)
    url.getHost -> Some(url.getPort).filter(_ > 0).getOrElse(80)
  }

  def extractHost(uri: String) = {
    val hostPort = extractHostAndPort(uri)
    new InetSocketAddress(hostPort._1, hostPort._2)
  }

  def stripHost(uri: String): String = {

    if (!httpPattern.matcher(uri).matches())
      uri
    else {
      val noHttpUri: String = uri.substring(uri.indexOf("://") + 3)
      val slashIndex = noHttpUri.indexOf("/")
      if (slashIndex == -1) "/"
      else noHttpUri.substring(slashIndex)
    }
  }

  def closeChannel(channel: Channel) {
    if (channel.isConnected)
      channel.write(ChannelBuffers.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE)
  }

  def toHex(data: Array[Byte]): String = {
    new String(Hex.encode(data), UTF8)
  }

  def formatMessage(message: Any): String = message match {
    case response: HttpMessage ⇒ s"$response \n length:  ${response.getContent.readableBytes()}\n ${hexDumpToString(response.getContent.array())}"
    case chunk: HttpChunk      ⇒ s"$chunk - isLast: ${chunk.isLast}} \n length:  ${chunk.getContent.readableBytes()}\n  ${hexDumpToString(chunk.getContent.array())}"
    case buffer: ChannelBuffer ⇒ s"$buffer \n length:  ${buffer.readableBytes()}\n  ${hexDumpToString(buffer.array())}"
    case unknownMessage        ⇒ "Unknown message."
  }

  def hexDumpToString(bytes: Array[Byte]): String = {
    if (bytes.length > 0) {
      //    val splitLine="-------------------------------------------------------------------------\n"
      val splitLine = "##################################################################"
      val output = new ByteArrayOutputStream()
      HexDump.dump(bytes, bytes.length, output, 0)
      splitLine + s"Length: ${bytes.length}\n" + IOUtils.toString(new ByteArrayInputStream(output.toByteArray)) + splitLine
    } else {
      "##############################EMPTY BUFFER###############################"
    }

  }

  import java.io.{ ObjectInputStream, ObjectOutputStream, ByteArrayInputStream, ByteArrayOutputStream }
  import java.util.zip.{ Deflater, Inflater }

  def deflate(in: Array[Byte]): Array[Byte] = {
    val compresser = new Deflater(Deflater.BEST_COMPRESSION)
    compresser.setInput(in)
    compresser.finish()
    val buf = new Array[Byte](DEFAULT_BUFFER_SIZE)
    val output = new ByteArrayOutputStream()
    while (!compresser.finished) {
      val count = compresser.deflate(buf)
      output.write(buf, 0, count)
    }
    output.toByteArray
  }

  def inflate(in: Array[Byte]): Array[Byte] = {
    val decompresser = new Inflater()
    decompresser.setInput(in)
    if (decompresser.needsInput()) {
      return Array[Byte]()
    }
    val buf = new Array[Byte](DEFAULT_BUFFER_SIZE)
    val output = new ByteArrayOutputStream()
    while (!decompresser.finished) {
      val count = decompresser.inflate(buf)
      output.write(buf, 0, count)
    }
    output.toByteArray
  }

  def serialize(obj: Any): Array[Byte] = {
    val baos = new ByteArrayOutputStream
    val oos = new ObjectOutputStream(baos)
    try {
      oos.writeObject(obj)
    } finally {
      oos.close()
    }
    baos.toByteArray
  }

  def deserialize[T](ba: Array[Byte]): T = {
    val bais = new ByteArrayInputStream(ba)
    val ois = new ObjectInputStream(bais)
    try {
      ois.readObject.asInstanceOf[T]
    } finally {
      ois.close()
    }
  }

  /**
   * Just for testing...
   */
  lazy val trustAllSSLContext = {
    val clientContext = SSLContext.getInstance("TLS")
    clientContext.init(null, Array(new X509TrustManager {
      def getAcceptedIssuers: Array[X509Certificate] = {
        return new Array[X509Certificate](0)
      }

      def checkClientTrusted(chain: Array[X509Certificate], authType: String) {
        System.err.println("Trust all client" + chain(0).getSubjectDN)
      }

      def checkServerTrusted(chain: Array[X509Certificate], authType: String) {
        System.err.println("Trust all server" + chain(0).getSubjectDN)
      }
    }), null)

    clientContext
  }

  def generateGFWHostList = {
    val list = scala.io.Source.fromInputStream(getClass.getResourceAsStream("/gfwlist.txt")).getLines().filterNot {
      line ⇒ line.startsWith("!") || line.startsWith("@@") || line.startsWith("/")
    }.toList

    val result = list.map {
      case line if (line.startsWith("||"))                        ⇒ Utils.extractHostAndPort(line.substring(2))._1
      case line if (line.startsWith("|") || line.startsWith(".")) ⇒ Utils.extractHostAndPort(line.substring(1))._1
      case line if (line.indexOf('*') > 0)                        ⇒ Utils.extractHostAndPort(line)._1
    }

    result.foreach(println _)

    //    list.filter(_.startsWith("||")).foreach(println _)
    //    list.filterNot(_.startsWith("||")).filter(_.startsWith("|")).foreach(println _)

    //    val request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "http://docs.google.com")
    //    val host = new GFWChainProxyManager().getConnectHost(request)(new SimpleProxyConfig)
    //    println(host)
  }

  def main(args: Array[String]) {

    val plain = Array(0x16, 0x03, 0x01, 0x00, 0xcb, 0x01, 0x00, 0x00, 0xc7, 0x03, 0x01, 0x52, 0x03, 0x64, 0x9d, 0xbc, 0x96, 0x8c, 0x04, 0xd2, 0x5e, 0x52, 0x5d, 0x17, 0x10, 0xd0, 0x19, 0x2b, 0x20, 0x72, 0xca, 0x2d, 0xc4, 0x62, 0x4c, 0x6e, 0x64, 0x3c, 0x91, 0x9f, 0xf2, 0xce, 0x5e, 0x20, 0xb7, 0x39, 0x94, 0xb7, 0x2e, 0x0b, 0x16, 0xc2, 0xc3, 0x57, 0x0e, 0x90, 0x60, 0xd6, 0xb0, 0x3d, 0x7b, 0xe0, 0x0e, 0xcb, 0x9c, 0x3f, 0xf0, 0x5e, 0x4a, 0xcf, 0xf4, 0x6e, 0x76, 0x9b, 0x64, 0x3c, 0x00, 0x48, 0x00, 0xff, 0xc0, 0x0a, 0xc0, 0x14, 0x00, 0x88, 0x00, 0x87, 0x00, 0x39, 0x00, 0x38, 0xc0, 0x0f, 0xc0, 0x05, 0x00, 0x84, 0x00, 0x35, 0xc0, 0x07, 0xc0, 0x09, 0xc0, 0x11, 0xc0, 0x13, 0x00, 0x45, 0x00, 0x44, 0x00, 0x33, 0x00, 0x32, 0xc0, 0x0c, 0xc0, 0x0e, 0xc0, 0x02, 0xc0, 0x04, 0x00, 0x96, 0x00, 0x41, 0x00, 0x05, 0x00, 0x04, 0x00, 0x2f, 0xc0, 0x08, 0xc0, 0x12, 0x00, 0x16, 0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03, 0xfe, 0xff, 0x00, 0x0a, 0x01, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x18, 0x00, 0x16, 0x00, 0x00, 0x13, 0x64, 0x65, 0x76, 0x65, 0x6c, 0x6f, 0x70, 0x65, 0x72, 0x2e, 0x61, 0x70, 0x70, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x00, 0x0a, 0x00, 0x08, 0x00, 0x06, 0x00, 0x17, 0x00, 0x18, 0x00, 0x19, 0x00, 0x0b, 0x00, 0x02, 0x01, 0x00, 0x00, 0x23, 0x00, 0x00, 0x33, 0x74, 0x00, 0x00)
    //    val compressed = Array(0x78, 0xda, 0x01, 0xe0, 0x00, 0x1f, 0xff, 0xfb, 0xc9, 0x3d, 0x3d, 0xb7, 0xad, 0x91, 0x50, 0x6e, 0x3d, 0x25, 0x19, 0x09, 0xb3, 0x77, 0xbd, 0x61, 0xb1, 0xcf, 0x51, 0x29, 0x03, 0xf9, 0x45, 0x7d, 0x72, 0x16, 0x7f, 0xec, 0xd1, 0xe2, 0x70, 0x16, 0xb6, 0x9a, 0xe5, 0xb6, 0xe7, 0x2f, 0x02, 0x29, 0x72, 0xa1, 0x03, 0xdd, 0x9b, 0xb5, 0x7f, 0x37, 0x6c, 0x8a, 0x1d, 0x85, 0xa0, 0x78, 0x67, 0x50, 0x77, 0xfb, 0xfa, 0xf4, 0x25, 0x01, 0x21, 0xfc, 0xfb, 0xab, 0x93, 0x65, 0xc9, 0xfd, 0x62, 0xcf, 0x81, 0xbb, 0x13, 0xac, 0xae, 0x3d, 0xf7, 0xb9, 0x42, 0x25, 0x30, 0x9b, 0xe1, 0x12, 0xb7, 0x6c, 0x83, 0x85, 0xa2, 0x57, 0xe1, 0x08, 0x30, 0x3f, 0xe5, 0xb9, 0x99, 0xb6, 0x69, 0xf2, 0xdc, 0x44, 0xbe, 0xb9, 0xb7, 0x9b, 0xbb, 0x72, 0xbd, 0x75, 0x88, 0x47, 0x82, 0xf9, 0xf5, 0xcf, 0x70, 0x79, 0x5f, 0xa7, 0xab, 0x63, 0xb7, 0x2e, 0x68, 0x5d, 0xf8, 0x31, 0xd9, 0x5b, 0x26, 0x68, 0x7d, 0x9b, 0x2b, 0xcf, 0xc8, 0x1d, 0x39, 0x36, 0x9f, 0x42, 0x45, 0x99, 0x04, 0x5b, 0x76, 0x8a, 0xba, 0x79, 0x8c, 0xca, 0xdd, 0x32, 0x88, 0x9f, 0xbb, 0xe7, 0xa9, 0x92, 0xdc, 0x59, 0x80, 0x2d, 0xfb, 0xfe, 0xa7, 0xb3, 0xf3, 0x62, 0x78, 0x80, 0xb2, 0x3e, 0xc4, 0x0d, 0x5e, 0x3a, 0xaa, 0x71, 0x11, 0xde, 0x6f, 0x5e, 0xbe, 0xf4, 0x5a, 0x12, 0x82, 0xfa, 0x17, 0x1a, 0x7f, 0xb8, 0xf5, 0x08, 0x6e, 0xb8, 0x97, 0x12, 0x36, 0x32, 0x87, 0xc8, 0xbe, 0x6d, 0x9a, 0x18, 0xce, 0xf1, 0x24, 0x2b, 0x5f, 0x74, 0xa0, 0xf6, 0xd3, 0x3f, 0x22, 0xbe, 0xe8, 0xdd, 0xfc, 0x74, 0x52).map(_.toByte)
    //        val compressed = Array(0x78,0xda,0x01,0xc0,0x01,0x3f,0xfe,0xb5,0x9a,0x52,0x69,0x87,0x9a,0xd1,0x33,0x48,0xb9,0x5f,0x9e,0x32,0x15,0x3a,0x20,0x82,0xd8,0x28,0xd3,0x2b,0x0c,0x6d,0x97,0xc7,0x76,0xcf,0xb3,0xf0,0xec,0x74,0x4f,0x54,0x3e,0x3a,0x52,0x6b,0x2b,0x6f,0x1a,0x17,0x33,0x0b,0xfa,0x62,0xfc,0x99,0xc9,0x6a,0x50,0xbe,0x5a,0x1d,0x1a,0xbc,0xf7,0x40,0xef,0xd3,0x26,0x98,0xe8,0x3e,0xcb,0x52,0x6c,0x1e,0x14,0xc3,0x10,0x93,0x26,0x2a,0x10,0xe3,0x51,0x6d,0xd5,0xe4,0xf1,0x87,0x72,0x69,0x3c,0x8b,0xa8,0x38,0x6a,0x2e,0xb9,0x7e,0xd7,0x24,0x95,0x07,0xf2,0xcf,0xa5,0xa6,0x6d,0x1a,0x36,0x6a,0xde,0x31,0xdd,0x9c,0x79,0x60,0xec,0xac,0xec,0xc6,0xa0,0x5d,0x8b,0x62,0xc8,0x2f,0xb5,0x14,0x61,0x83,0xb3,0x3b,0x5a,0x8d,0xc5,0x91,0x44,0xe6,0x40,0x50,0x4e,0x1b,0xd2,0x04,0x18,0xc1,0xf1,0x61,0x44,0xc6,0x05,0x92,0x64,0x4a,0x71,0xdb,0xec,0xcc,0x12,0x5b,0xf2,0x78,0xcd,0xc1,0x44,0xfa,0x5f,0xcf,0x07,0xbf,0x95,0x6b,0xa3,0x9d,0x1b,0x88,0x4d,0xd4,0xe2,0xb1,0xf8,0x89,0x8d,0x85,0x50,0x2b,0x4e,0xfe,0x63,0x3b,0x36,0xb3,0x49,0x0a,0x7e,0xba,0x11,0xfe,0x9e,0xf3,0xbb,0x2c,0x43,0x9c,0xdc,0x69,0x12,0xe4,0x1a,0xad,0x70,0x4d,0x44,0x27,0x0b,0x9a,0x29,0x3e,0x5f,0xa2,0x24,0x44,0xe1,0x08,0xa2,0xd7,0x47,0x37,0x79,0x0a,0xb1,0xc9,0xcf,0xe9,0xa2,0x70,0x1d,0xbe,0x59,0x06,0x73,0x01,0x73,0xfb,0x76,0x42,0xaf,0x86,0x89,0x89,0x6a,0xb2,0xce,0xc0,0x9b,0xaf,0x65,0xc9,0x8d,0xeb,0xc0,0xfe,0x08,0x1c,0x5b,0x51,0x20,0x02,0x6b,0xf5,0xdc,0x73,0x67,0x81,0xba,0x70,0x08,0xe5,0xc5,0xd8,0x1b,0x4f,0xa6,0x1c,0x58,0x64,0x1d,0xf3,0x6d,0x70,0x46,0x44,0x15,0x66,0x0f,0x02,0x9e,0x72,0xd4,0xa9,0x50,0xd3,0x6c,0xb5,0x79,0xbb,0xe7,0xdd,0x39,0xb3,0x6a,0x89,0xaf,0x0f,0x71,0xfb,0xbc,0x30,0x1c,0x54,0x8a,0x2d,0xc1,0xb9,0x99,0xc5,0x29,0x4a,0xb7,0x0f,0xff,0x63,0x61,0xa0,0x97,0xbb,0x5f,0xe2,0x44,0x56,0x5e,0xe6,0xa5,0x36,0xd0,0x94,0x59,0x75,0x4b,0x46,0x98,0x27,0x2e,0x0d,0xf9,0x62,0xe4,0x1d,0xdf,0xd5,0xc5,0x6a,0x29,0xb2,0xe4,0x14,0x20,0xa1,0xe9,0x5e,0xc4,0xfb,0x6a,0x54,0xd2,0xdb,0x73,0xc8,0x2f,0x61,0x2c,0xcd,0xc6,0x39,0x19,0x84,0xe2,0xee,0xc8,0x14,0x2c,0xdb,0x32,0x30,0xef,0x7f,0x4a,0x93,0x12,0x47,0x61,0xc3,0x38,0x2d,0x87,0x88,0xb0,0xb9,0x8d,0x1c,0x7c,0x0f,0x57,0xb4,0x23,0x50,0xab,0x48,0x83,0x54,0xaf,0xaa,0xec,0x38,0x25,0xf6,0xaa,0x3b,0xd0,0x7e,0x2a,0xf9,0xa5,0x34,0x7f,0x73,0xbb,0xa9,0xff,0x62,0x18,0x95,0x47,0xd6,0x4a,0x9a,0xf3,0x5f,0xc6,0xa1,0xa2,0x9a,0x63,0x02,0xda,0x1c,0xd3,0xdc,0x71).map(_.toByte)
    val compressed = Array(0x78, 0xda, 0x01, 0xc0, 0x01, 0x3f, 0xfe, 0xb5, 0x9a, 0x52, 0x69, 0x87, 0x9a, 0xd1, 0x33, 0x48, 0xb9, 0x5f, 0x9e, 0x32, 0x15, 0x3a, 0x20, 0x82, 0xd8, 0x28, 0xd3, 0x2b, 0x0c, 0x6d, 0x97, 0xc7, 0x76, 0xcf, 0xb3, 0xf0, 0xec, 0x74, 0x4f, 0x54, 0x3e, 0x3a, 0x52, 0x6b, 0x2b, 0x6f, 0x1a, 0x17, 0x33, 0x0b, 0xfa, 0x62, 0xfc, 0x99, 0xc9, 0x6a, 0x50, 0xbe, 0x5a, 0x1d, 0x1a, 0xbc, 0xf7, 0x40, 0xef, 0xd3, 0x26, 0x98, 0xe8, 0x3e, 0xcb, 0x52, 0x6c, 0x1e, 0x14, 0xc3, 0x10, 0x93, 0x26, 0x2a, 0x10, 0xe3, 0x51, 0x6d, 0xd5, 0xe4, 0xf1, 0x87, 0x72, 0x69, 0x3c, 0x8b, 0xa8, 0x38, 0x6a, 0x2e, 0xb9, 0x7e, 0xd7, 0x24, 0x95, 0x07, 0xf2, 0xcf, 0xa5, 0xa6, 0x6d, 0x1a, 0x36, 0x6a, 0xde, 0x31, 0xdd, 0x9c, 0x79, 0x60, 0xec, 0xac, 0xec, 0xc6, 0xa0, 0x5d, 0x8b, 0x62, 0xc8, 0x2f, 0xb5, 0x14, 0x61, 0x83, 0xb3, 0x3b, 0x5a, 0x8d, 0xc5, 0x91, 0x44, 0xe6, 0x40, 0x50, 0x4e, 0x1b, 0xd2, 0x04, 0x18, 0xc1, 0xf1, 0x61, 0x44, 0xc6, 0x05, 0x92, 0x64, 0x4a, 0x71, 0xdb, 0xec, 0xcc, 0x12, 0x5b, 0xf2, 0x78, 0xcd, 0xc1, 0x44, 0xfa, 0x5f, 0xcf, 0x07, 0xbf, 0x95, 0x6b, 0xa3, 0x9d, 0x1b, 0x88, 0x4d, 0xd4, 0xe2, 0xb1, 0xf8, 0x89, 0x8d, 0x85, 0x50, 0x2b, 0x4e, 0xfe, 0x63, 0x3b, 0x36, 0xb3, 0x49, 0x0a, 0x7e, 0xba, 0x11, 0xfe, 0x9e, 0xf3, 0xbb, 0x2c, 0x43, 0x9c, 0xdc, 0x69, 0x12, 0xe4, 0x1a, 0xad, 0x70, 0x4d, 0x44, 0x27, 0x0b, 0x9a, 0x29, 0x3e, 0x5f, 0xa2, 0x24, 0x44, 0xe1, 0x08, 0xa2, 0xd7, 0x47, 0x37, 0x79, 0x0a, 0xb1, 0xc9, 0xcf, 0xe9, 0xa2, 0x70, 0x1d, 0xbe, 0x59, 0x06, 0x73, 0x01, 0x73, 0xfb, 0x76, 0x42, 0xaf, 0x86, 0x89, 0x89, 0x6a, 0xb2, 0xce, 0xc0, 0x9b, 0xaf, 0x65, 0xc9, 0x8d, 0xeb, 0xc0, 0xfe, 0x08, 0x1c, 0x5b, 0x51, 0x20, 0x02, 0x6b, 0xf5, 0xdc, 0x73, 0x67, 0x81, 0xba, 0x70, 0x08, 0xe5, 0xc5, 0xd8, 0x1b, 0x4f, 0xa6, 0x1c, 0x58, 0x64, 0x1d, 0xf3, 0x6d, 0x70, 0x46, 0x44, 0x15, 0x66, 0x0f, 0x02, 0x9e, 0x72, 0xd4, 0xa9, 0x50, 0xd3, 0x6c, 0xb5, 0x79, 0xbb, 0xe7, 0xdd, 0x39, 0xb3, 0x6a, 0x89, 0xaf, 0x0f, 0x71, 0xfb, 0xbc, 0x30, 0x1c, 0x54, 0x8a, 0x2d, 0xc1, 0xb9, 0x99, 0xc5, 0x29, 0x4a, 0xb7, 0x0f, 0xff, 0x63, 0x61, 0xa0, 0x97, 0xbb, 0x5f, 0xe2, 0x44, 0x56, 0x5e, 0xe6, 0xa5, 0x36, 0xd0, 0x94, 0x59, 0x75, 0x4b, 0x46, 0x98, 0x27, 0x2e, 0x0d, 0xf9, 0x62, 0xe4, 0x1d, 0xdf, 0xd5, 0xc5, 0x6a, 0x29, 0xb2, 0xe4, 0x14, 0x20, 0xa1, 0xe9, 0x5e, 0xc4, 0xfb, 0x6a, 0x54, 0xd2, 0xdb, 0x73, 0xc8, 0x2f, 0x61, 0x2c, 0xcd, 0xc6, 0x39, 0x19, 0x84, 0xe2, 0xee, 0xc8, 0x14, 0x2c, 0xdb, 0x32, 0x30, 0xef, 0x7f, 0x4a, 0x93, 0x12, 0x47, 0x61, 0xc3, 0x38, 0x2d, 0x87, 0x88, 0xb0, 0xb9, 0x8d, 0x1c, 0x7c, 0x0f, 0x57, 0xb4, 0x23, 0x50, 0xab, 0x48, 0x83, 0x54, 0xaf, 0xaa, 0xec, 0x38, 0x25, 0xf6, 0xaa, 0x3b, 0xd0, 0x7e, 0x2a, 0xf9, 0xa5, 0x34, 0x7f, 0x73, 0xbb, 0xa9, 0xff, 0x62, 0x18, 0x95, 0x47, 0xd6, 0x4a, 0x9a, 0xf3, 0x5f, 0xc6, 0xa1, 0xa2, 0x9a, 0x63, 0x02, 0xda, 0x1c, 0xd3, 0xdc, 0x71).map(_.toByte)
    //    println(hexDumpToString(Utils.deflate(encryptor.encrypt(plain.map(_.toByte)))))
    //
    //    println(hexDumpToString(IOUtils.toByteArray(new ByteArrayInputStream(compressed))))
    println(hexDumpToString(encryptor.decrypt(Utils.inflate(compressed))))

    val deflateData: Array[Byte] = Utils.deflate(encryptor.encrypt(plain.map(_.toByte)))
    require(compressed.length == deflateData.length)
    compressed.zip(deflateData).foreach {
      case (a, b) ⇒ require(a == b)
    }

    val dePlain = encryptor.decrypt(Utils.inflate(compressed))
    println(hexDumpToString(dePlain))
    require(plain.length == dePlain.length)
    plain.zip(dePlain).foreach {
      case (a, b) ⇒ {
        if (a != b) {
          println(a -> b)
          println(toHex(Array(a.toByte)) -> toHex(Array(b.toByte)))
        }
      }
    }

    Utils.inflate(Array[Byte]())

    println(new SecureRandom().generateSeed(64).mkString(","))

    Security.addProvider(new BouncyCastleProvider());
    val keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
    keyPairGenerator.initialize(2048);
    val keyPair = keyPairGenerator.generateKeyPair();

    val keyFac = KeyFactory.getInstance("RSA", "BC");
    val publicKeySpec = keyFac.getKeySpec(keyPair.getPublic(), classOf[RSAPublicKeySpec]);
    val privateCrtKeySpec = keyFac.getKeySpec(keyPair.getPrivate(), classOf[RSAPrivateCrtKeySpec]);
    println("==================Server KeyPair========================================")
    println("=========================Public========================================")
    println(toHex(privateCrtKeySpec.getModulus().toByteArray()))
    println(toHex(privateCrtKeySpec.getPublicExponent().toByteArray()))

    //
    //    System.out.println("==================Server KeyPair========================================");
    //    System.out.println("=========================Public========================================");
    //    System.out.println(toHex(publicKeySpec.getModulus().toByteArray()));
    //    System.out.println(toHex(publicKeySpec.getPublicExponent().toByteArray()));
    //    System.out.println("=========================Private========================================");
    //    System.out.println(toHex(privateCrtKeySpec.getModulus().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getPublicExponent().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getPrivateExponent().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getPrimeP().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getPrimeQ().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getPrimeExponentP().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getPrimeExponentQ().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getCrtCoefficient().toByteArray()));
    //
    //    System.out.println("==================Server KeyPair========================================");
    //    System.out.println("=========================Public========================================");
    //    System.out.println(toHex(publicKeySpec.getModulus().toByteArray()));
    //    System.out.println(toHex(publicKeySpec.getPublicExponent().toByteArray()));
    //    System.out.println("=========================Private========================================");
    //    System.out.println(toHex(privateCrtKeySpec.getModulus().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getPublicExponent().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getPrivateExponent().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getPrimeP().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getPrimeQ().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getPrimeExponentP().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getPrimeExponentQ().toByteArray()));
    //    System.out.println(toHex(privateCrtKeySpec.getCrtCoefficient().toByteArray()));
    //
    //

  }

}

